# -*- coding: utf-8 -*-
"""Lab-Mid.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yIJV72KuFvs1xjbbGoqoY7i4ZX6v0MPQ

## Question No 1
"""

import heapq

# Represents the puzzle grid
class PuzzleState:
    def __init__(self, board, parent=None, move=None, depth=0, cost=0):
        self.board = board  # 2D list representing the grid
        self.parent = parent  # Parent state in the search path
        self.move = move  # Move that led to this state
        self.depth = depth  # Depth of the state in the search tree
        self.cost = cost  # Cost to reach this state (for A*)

    def __lt__(self, other):
        # For priority queue in A*
        return (self.cost + self.manhattan_distance()) < (other.cost + other.manhattan_distance())

    def __eq__(self, other):
        return self.board == other.board

    def __hash__(self):
        return hash(str(self.board))

    def get_blank_position(self):
        # Find the position of the blank tile (0)
        for i in range(3):
            for j in range(3):
                if self.board[i][j] == 0:
                    return (i, j)
        return None

    def get_possible_moves(self):
        # Get possible moves (Up, Down, Left, Right)
        row, col = self.get_blank_position()
        moves = []
        if row > 0:
            moves.append("Up")
        if row < 2:
            moves.append("Down")
        if col > 0:
            moves.append("Left")
        if col < 2:
            moves.append("Right")
        return moves

    def get_next_state(self, move):
        # Get the next state after making a move
        row, col = self.get_blank_position()
        new_board = [list(row) for row in self.board]

        if move == "Up":
            new_board[row][col], new_board[row - 1][col] = new_board[row - 1][col], new_board[row][col]
        elif move == "Down":
            new_board[row][col], new_board[row + 1][col] = new_board[row + 1][col], new_board[row][col]
        elif move == "Left":
            new_board[row][col], new_board[row][col - 1] = new_board[row][col - 1], new_board[row][col]
        elif move == "Right":
            new_board[row][col], new_board[row][col + 1] = new_board[row][col + 1], new_board[row][col]

        return PuzzleState(new_board, self, move, self.depth + 1, self.cost + 1)

    def is_goal(self, goal_state):
        return self.board == goal_state.board

    def manhattan_distance(self):
        # Calculate Manhattan distance heuristic
        distance = 0
        for i in range(3):
            for j in range(3):
                tile = self.board[i][j]
                if tile != 0:
                    goal_row, goal_col = divmod(tile - 1, 3)
                    distance += abs(i - goal_row) + abs(j - goal_col)
        return distance

# --- Search Algorithms ---

def solve_bfs(start_state, goal_state):
    queue = [start_state]
    visited = {start_state}

    while queue:
        current_state = queue.pop(0)

        if current_state.is_goal(goal_state):
            return get_solution_path(current_state)

        for move in current_state.get_possible_moves():
            next_state = current_state.get_next_state(move)
            if next_state not in visited:
                queue.append(next_state)
                visited.add(next_state)

    return None  # No solution found

def solve_dfs(start_state, goal_state):
    stack = [start_state]
    visited = {start_state}

    while stack:
        current_state = stack.pop()

        if current_state.is_goal(goal_state):
            return get_solution_path(current_state)

        for move in reversed(current_state.get_possible_moves()): # Reverse to explore left/up first
            next_state = current_state.get_next_state(move)
            if next_state not in visited:
                stack.append(next_state)
                visited.add(next_state)

    return None  # No solution found

def solve_astar(start_state, goal_state):
    open_set = [(start_state.cost + start_state.manhattan_distance(), start_state)]
    heapq.heapify(open_set)
    came_from = {}
    g_score = {start_state: 0}

    while open_set:
        f_score, current_state = heapq.heappop(open_set)

        if current_state.is_goal(goal_state):
            return get_solution_path(current_state)

        for move in current_state.get_possible_moves():
            neighbor = current_state.get_next_state(move)
            tentative_g_score = g_score[current_state] + 1

            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current_state
                g_score[neighbor] = tentative_g_score
                heapq.heappush(open_set, (g_score[neighbor] + neighbor.manhattan_distance(), neighbor))

    return None  # No solution found

def get_solution_path(goal_state):
    # Reconstruct the solution path from the goal state
    path = []
    current_state = goal_state
    while current_state:
        path.append(current_state)
        current_state = current_state.parent
    return path[::-1]  # Reverse the path to get from start to goal

def print_puzzle_state(state):
    for row in state.board:
        print(row)
    print("-" * 10)

# --- Example Usage ---

# Define the initial and goal states
start_board = [
    [1, 2, 3],
    [4, 0, 6],
    [7, 5, 8]
]

goal_board = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

start_state = PuzzleState(start_board)
goal_state = PuzzleState(goal_board)

# Solve using BFS
print("Solving with BFS:")
bfs_solution = solve_bfs(start_state, goal_state)
if bfs_solution:
    for state in bfs_solution:
        print_puzzle_state(state)
else:
    print("No solution found with BFS.")

print("\n" + "="*20 + "\n")

# Solve using DFS
print("Solving with DFS:")
dfs_solution = solve_dfs(start_state, goal_state)
if dfs_solution:
    for state in dfs_solution:
        print_puzzle_state(state)
else:
    print("No solution found with DFS.")

print("\n" + "="*20 + "\n")

# Solve using A*
print("Solving with A*:")
astar_solution = solve_astar(start_state, goal_state)
if astar_solution:
    for state in astar_solution:
        print_puzzle_state(state)
else:
    print("No solution found with A*.")