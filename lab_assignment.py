# -*- coding: utf-8 -*-
"""Lab Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t3b9lmH8SQ-n-aqcxwEIxanYFewBQWwH

# **Task 2**
"""

student_info = {
    "name": "Alice",
    "age": 16,
    "roll_number": "A123",
    "grade": "10th"
}

# 1. Print all keys and values
print("All keys and values:")
for key, value in student_info.items():
    print(f"{key}: {value}")
print("-" * 20)

# 2. Update the grade of the student
student_info["grade"] = "11th"
print("Updated grade:")
print(f"Grade: {student_info['grade']}")
print("-" * 20)

# 3. Add a new key email with a value
student_info["email"] = "alice@example.com"
print("Added email:")
print(f"Email: {student_info['email']}")
print("-" * 20)

# 4. Delete the roll_number key
del student_info["roll_number"]
print("Dictionary after deleting roll_number:")
print(student_info)

"""# **Task 3**"""

# 1. Import the Matplotlib library
import matplotlib.pyplot as plt

# 2. Create data for the plot
X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

# Create a simple line plot
plt.plot(X, Y)

# 3. Add title, labels, and grid lines
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.grid(True)

# Display the plot
plt.show()

"""# **Task 5**
Implement and compare BFS and DFS algorithms for the Water Jug problem, measuring steps, time, and memory usage.

## Define the water jug problem

### Subtask:
Represent the states (water levels in each jug) and possible actions (filling, emptying, pouring).

**Reasoning**:
Define a class to represent the state of the water jugs and implement the possible actions as methods within the class.
"""

class WaterJugState:
    """Represents the state of the water jugs."""

    def __init__(self, jug1_level, jug2_level, jug1_capacity, jug2_capacity):
        """Initializes the state with current levels and capacities."""
        self.jug1_level = jug1_level
        self.jug2_level = jug2_level
        self.jug1_capacity = jug1_capacity
        self.jug2_capacity = jug2_capacity

    def __eq__(self, other):
        """Compares two states for equality."""
        return (self.jug1_level == other.jug1_level and
                self.jug2_level == other.jug2_level)

    def __hash__(self):
        """Generates a hash for the state."""
        return hash((self.jug1_level, self.jug2_level))

    def fill_jug1(self):
        """Fills jug 1 to its capacity."""
        return WaterJugState(self.jug1_capacity, self.jug2_level, self.jug1_capacity, self.jug2_capacity)

    def fill_jug2(self):
        """Fills jug 2 to its capacity."""
        return WaterJugState(self.jug1_level, self.jug2_capacity, self.jug1_capacity, self.jug2_capacity)

    def empty_jug1(self):
        """Empties jug 1."""
        return WaterJugState(0, self.jug2_level, self.jug1_capacity, self.jug2_capacity)

    def empty_jug2(self):
        """Empties jug 2."""
        return WaterJugState(self.jug1_level, 0, self.jug1_capacity, self.jug2_capacity)

    def pour_jug1_to_jug2(self):
        """Pours water from jug 1 to jug 2."""
        pour_amount = min(self.jug1_level, self.jug2_capacity - self.jug2_level)
        new_jug1_level = self.jug1_level - pour_amount
        new_jug2_level = self.jug2_level + pour_amount
        return WaterJugState(new_jug1_level, new_jug2_level, self.jug1_capacity, self.jug2_capacity)

    def pour_jug2_to_jug1(self):
        """Pours water from jug 2 to jug 1."""
        pour_amount = min(self.jug2_level, self.jug1_capacity - self.jug1_level)
        new_jug2_level = self.jug2_level - pour_amount
        new_jug1_level = self.jug1_level + pour_amount
        return WaterJugState(new_jug1_level, new_jug2_level, self.jug1_capacity, self.jug2_capacity)

    def get_possible_actions(self):
        """Returns a list of possible next states from the current state."""
        actions = []
        actions.append(self.fill_jug1())
        actions.append(self.fill_jug2())
        actions.append(self.empty_jug1())
        actions.append(self.empty_jug2())
        actions.append(self.pour_jug1_to_jug2())
        actions.append(self.pour_jug2_to_jug1())
        return actions

    def __str__(self):
        """Returns a string representation of the state."""
        return f"({self.jug1_level}, {self.jug2_level})"

# Example usage:
initial_state = WaterJugState(0, 0, 4, 3)
print(f"Initial state: {initial_state}")

# Demonstrate some actions
filled_jug1 = initial_state.fill_jug1()
print(f"After filling jug 1: {filled_jug1}")

poured_state = filled_jug1.pour_jug1_to_jug2()
print(f"After pouring jug 1 to jug 2: {poured_state}")

empty_jug2 = poured_state.empty_jug2()
print(f"After emptying jug 2: {empty_jug2}")

print("Possible actions from initial state:")
for state in initial_state.get_possible_actions():
    print(state)

"""## Implement bfs

### Subtask:
Write a function that performs a Breadth-First Search to find a solution.

**Reasoning**:
Define the BFS function as per the instructions, including initializing the queue and visited set, looping until the queue is empty, checking for the goal state, generating next states, and handling visited states.
"""

from collections import deque

def bfs(initial_state, goal_state):
    """Performs a Breadth-First Search to find a solution for the Water Jug problem."""
    queue = deque([(initial_state, [initial_state])]) # Store state and path
    visited = {initial_state}

    while queue:
        current_state, path = queue.popleft()

        if current_state == goal_state:
            return path  # Goal reached, return the path

        for next_state in current_state.get_possible_actions():
            if next_state not in visited:
                visited.add(next_state)
                queue.append((next_state, path + [next_state]))

    return None  # No solution found

# Example usage (assuming initial_state and goal_state are defined WaterJugState objects)
# initial_state = WaterJugState(0, 0, 4, 3)
# goal_state = WaterJugState(2, 0, 4, 3) # Example goal
# solution_path = bfs(initial_state, goal_state)

# if solution_path:
#     print("Solution found (BFS):")
#     for state in solution_path:
#         print(state)
# else:
#     print("No solution found (BFS).")

"""## Implement dfs

### Subtask:
Write a function that performs a Depth-First Search to find a solution.

**Reasoning**:
Implement the DFS function as per the instructions, using a stack and visited set to explore states and their paths.
"""

def dfs(initial_state, goal_state):
    """Performs a Depth-First Search to find a solution for the Water Jug problem."""
    stack = [(initial_state, [initial_state])]  # Stack stores state and path
    visited = set()

    while stack:
        current_state, path = stack.pop() # Pop from the end for DFS

        if current_state == goal_state:
            return path  # Goal reached, return the path

        # Check if already visited
        if current_state in visited:
            continue

        visited.add(current_state)

        # Get next states and push onto stack (in reverse order for consistent exploration)
        possible_next_states = current_state.get_possible_actions()
        # Reverse the order to process states in a predictable manner (e.g., fill_jug2 before fill_jug1 if they are added in that order)
        for next_state in reversed(possible_next_states):
             if next_state not in visited:
                stack.append((next_state, path + [next_state]))


    return None  # No solution found

# Example usage (assuming initial_state and goal_state are defined WaterJugState objects)
# initial_state = WaterJugState(0, 0, 4, 3)
# goal_state = WaterJugState(2, 0, 4, 3) # Example goal
# solution_path_dfs = dfs(initial_state, goal_state)

# if solution_path_dfs:
#     print("Solution found (DFS):")
#     for state in solution_path_dfs:
#         print(state)
# else:
#     print("No solution found (DFS).")

"""## Compare performance

### Subtask:
Write code to run both algorithms on the same problem instance and measure the number of steps, time taken, and memory usage.

**Reasoning**:
Import necessary libraries for time and memory measurement and define the initial and goal states.
"""

import time
import sys

# Define the initial and goal states for the Water Jug problem
# Example: Jug capacities 4 and 3, goal is to get 2 in the 4-liter jug
initial_state = WaterJugState(0, 0, 4, 3)
goal_state = WaterJugState(2, 0, 4, 3)

"""**Reasoning**:
Run the BFS algorithm, measure time, count steps, and approximate memory usage.


"""

# Run BFS and measure performance
bfs_start_time = time.time()
bfs_solution_path = bfs(initial_state, goal_state)
bfs_end_time = time.time()

bfs_time_taken = bfs_end_time - bfs_start_time

# To count steps (visited states) and approximate memory, we need to modify the bfs function
# or access internal variables if possible. Since we cannot modify previous code,
# we will approximate memory by tracking the size of the solution path and the initial state.
# A more accurate measure would require modifying the function to return visited set/queue size.

# Approximate steps by path length if solution found, otherwise 0 or a large number
bfs_steps = len(bfs_solution_path) if bfs_solution_path else 0 # This is an approximation, not the actual visited count

# Approximate memory by the size of the initial state and the solution path
bfs_memory_approx = sys.getsizeof(initial_state) + sys.getsizeof(bfs_solution_path) if bfs_solution_path else sys.getsizeof(initial_state)

print(f"BFS Results:")
if bfs_solution_path:
    print(f"  Solution found in {len(bfs_solution_path) - 1} steps.") # steps exclude initial state
    print(f"  Time taken: {bfs_time_taken:.6f} seconds")
    print(f"  Approximate memory usage (initial state + path): {bfs_memory_approx} bytes")
else:
    print("  No solution found.")
    print(f"  Time taken: {bfs_time_taken:.6f} seconds")
    print(f"  Approximate memory usage (initial state): {bfs_memory_approx} bytes")

"""**Reasoning**:
Run the DFS algorithm, measure time, count steps, and approximate memory usage, then store the results for both algorithms.


"""

# Run DFS and measure performance
dfs_start_time = time.time()
dfs_solution_path = dfs(initial_state, goal_state)
dfs_end_time = time.time()

dfs_time_taken = dfs_end_time - dfs_start_time

# Approximate steps by path length if solution found, otherwise 0 or a large number
dfs_steps = len(dfs_solution_path) if dfs_solution_path else 0 # This is an approximation

# Approximate memory by the size of the initial state and the solution path
dfs_memory_approx = sys.getsizeof(initial_state) + sys.getsizeof(dfs_solution_path) if dfs_solution_path else sys.getsizeof(initial_state)

print(f"\nDFS Results:")
if dfs_solution_path:
    print(f"  Solution found in {len(dfs_solution_path) - 1} steps.") # steps exclude initial state
    print(f"  Time taken: {dfs_time_taken:.6f} seconds")
    print(f"  Approximate memory usage (initial state + path): {dfs_memory_approx} bytes")
else:
    print("  No solution found.")
    print(f"  Time taken: {dfs_time_taken:.6f} seconds")
    print(f"  Approximate memory usage (initial state): {dfs_memory_approx} bytes")

# Store the results
bfs_results = {
    "algorithm": "BFS",
    "steps": bfs_steps,
    "time_taken": bfs_time_taken,
    "memory_approx": bfs_memory_approx
}

dfs_results = {
    "algorithm": "DFS",
    "steps": dfs_steps,
    "time_taken": dfs_time_taken,
    "memory_approx": dfs_memory_approx
}

print("\nStored Results:")
print(bfs_results)
print(dfs_results)

"""## Present results

### Subtask:
Display the performance comparison in a clear format.

**Reasoning**:
Display the performance comparison results stored in the `bfs_results` and `dfs_results` dictionaries, following the specified format.
"""

print("--- Performance Comparison: Water Jug Problem ---")
print("\nBreadth-First Search (BFS) Results:")
print(f"  Algorithm: {bfs_results['algorithm']}")
print(f"  Steps Taken: {bfs_results['steps']}")
print(f"  Time Taken: {bfs_results['time_taken']:.6f} seconds")
print(f"  Approximate Memory Usage: {bfs_results['memory_approx']} bytes")

print("\nDepth-First Search (DFS) Results:")
print(f"  Algorithm: {dfs_results['algorithm']}")
print(f"  Steps Taken: {dfs_results['steps']}")
print(f"  Time Taken: {dfs_results['time_taken']:.6f} seconds")
print(f"  Approximate Memory Usage: {dfs_results['memory_approx']} bytes")

print("\n--- Summary ---")
if bfs_results['steps'] < dfs_results['steps']:
    print("For this specific problem instance, BFS found a solution in fewer steps.")
elif bfs_results['steps'] > dfs_results['steps']:
     print("For this specific problem instance, DFS found a solution in fewer steps.")
else:
    print("For this specific problem instance, both algorithms found a solution in the same number of steps.")

if bfs_results['time_taken'] < dfs_results['time_taken']:
    print("BFS was faster than DFS for this specific problem instance.")
elif bfs_results['time_taken'] > dfs_results['time_taken']:
    print("DFS was faster than BFS for this specific problem instance.")
else:
    print("Both algorithms took approximately the same time for this specific problem instance.")

if bfs_results['memory_approx'] < dfs_results['memory_approx']:
    print("BFS used less approximate memory than DFS for this specific problem instance.")
elif bfs_results['memory_approx'] > dfs_results['memory_approx']:
    print("DFS used less approximate memory than BFS for this specific problem instance.")
else:
    print("Both algorithms used approximately the same memory for this specific problem instance.")

print("\nNote: Steps and memory usage are approximations based on the solution path length and size.")

"""## Summary:

### Data Analysis Key Findings

*   Both BFS and DFS successfully found a solution for the Water Jug problem with jug capacities of 4 and 3 liters, aiming to get 2 liters in the 4-liter jug (initial state (0,0), goal state (2,0)).
*   BFS found a shorter solution path (7 steps including the initial state) compared to DFS (9 steps including the initial state) for this specific instance.
*   BFS was faster (0.000431 seconds) than DFS (0.001015 seconds) for this specific problem instance.
*   The approximate memory usage, calculated based on the initial state and the solution path size, was slightly lower for BFS (160 bytes) than for DFS (176 bytes) in this case.

### Insights or Next Steps

*   For problems where the shortest path is desired and the state space is not excessively large, BFS is generally preferred as it guarantees finding the shortest path.
*   The memory usage approximation based solely on the solution path might be misleading; a more accurate comparison would require tracking the maximum size of the queue (for BFS) or stack (for DFS) and the visited set during execution.

# Task 6
Implement an A* search to find the path from 'A' to 'Y' in the maze represented by the image "/content/Screenshot 2025-10-13 221132.png", and visualize the resulting path on the maze image.

## Load and process the maze image

### Subtask:
Load the image and convert it into a format that can be used to represent the maze as a graph.

**Reasoning**:
Load the maze image, convert it to grayscale, apply a binary threshold, and invert the image to prepare it for graph representation. Then display the processed image.
"""

import cv2
import numpy as np

# Load the maze image
image_path = "/content/Screenshot 2025-10-13 221132.png"
maze_image = cv2.imread(image_path)

# Convert to grayscale
gray_maze = cv2.cvtColor(maze_image, cv2.COLOR_BGR2GRAY)

# Apply binary threshold
# Assuming walls are dark and paths are light, we threshold to keep paths white (255)
# The threshold value 100 is a starting point and might need adjustment based on the image.
ret, binary_maze = cv2.threshold(gray_maze, 100, 255, cv2.THRESH_BINARY)

# Invert the image so paths are 255 and walls are 0
inverted_binary_maze = cv2.bitwise_not(binary_maze)

# Display the processed binary image
cv2.imshow("Processed Maze", inverted_binary_maze)
cv2.waitKey(0)
cv2.destroyAllWindows()

"""**Reasoning**:
The previous command failed because `cv2.imshow()` is disabled in the current environment. I need to use the recommended alternative `cv2_imshow` from `google.colab.patches` to display the image.


"""

from google.colab.patches import cv2_imshow

# Load the maze image
image_path = "/content/Screenshot 2025-10-13 221132.png"
maze_image = cv2.imread(image_path)

# Convert to grayscale
gray_maze = cv2.cvtColor(maze_image, cv2.COLOR_BGR2GRAY)

# Apply binary threshold
# Assuming walls are dark and paths are light, we threshold to keep paths white (255)
# The threshold value 100 is a starting point and might need adjustment based on the image.
ret, binary_maze = cv2.threshold(gray_maze, 100, 255, cv2.THRESH_BINARY)

# Invert the image so paths are 255 and walls are 0
inverted_binary_maze = cv2.bitwise_not(binary_maze)

# Display the processed binary image using cv2_imshow
cv2_imshow(inverted_binary_maze)

"""## Define the maze as a graph

### Subtask:
Create a graph representation of the maze where nodes are the traversable cells and edges connect adjacent traversable cells.

**Reasoning**:
Get the dimensions of the maze and create a graph representation by iterating through the cells and adding edges between adjacent traversable cells.
"""

height, width = inverted_binary_maze.shape
graph = {}

for r in range(height):
    for c in range(width):
        if inverted_binary_maze[r, c] == 255:  # Check if it's a traversable path
            neighbors = []
            # Define possible movements (up, down, left, right)
            movements = [(-1, 0), (1, 0), (0, -1), (0, 1)]

            for dr, dc in movements:
                new_r, new_c = r + dr, c + dc

                # Check if the adjacent cell is within bounds
                if 0 <= new_r < height and 0 <= new_c < width:
                    # Check if the adjacent cell is also a traversable path
                    if inverted_binary_maze[new_r, new_c] == 255:
                        neighbors.append((new_r, new_c))
            graph[(r, c)] = neighbors

# Print a small portion of the graph to verify
print("Sample of the generated graph:")
sample_keys = list(graph.keys())[:10] # Print first 10 keys
for key in sample_keys:
    print(f"{key}: {graph[key]}")

"""## Implement the a* search algorithm

### Subtask:
Write a function that performs the A* search to find the shortest path from the start node (A) to the goal node (Y).

**Reasoning**:
Implement the A* search algorithm to find the shortest path in the maze graph, incorporating the instructions for initializing data structures, the main loop, goal checking, neighbor processing, and using a heuristic function.
"""

import heapq
import math

def heuristic(a, b):
    """Calculates the Manhattan distance between two points."""
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star_search(graph, start, goal):
    """Performs A* search to find the shortest path."""
    # Initialize the open set (priority queue) and closed set
    open_set = []
    heapq.heappush(open_set, (0, start))  # (f_score, node)

    came_from = {}

    # Initialize g_score and f_score dictionaries
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0

    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)

    while open_set:
        # Get the node with the lowest f_score from the open set
        current_f, current_node = heapq.heappop(open_set)

        # If the current node is the goal, reconstruct and return the path
        if current_node == goal:
            path = []
            while current_node in came_from:
                path.append(current_node)
                current_node = came_from[current_node]
            path.append(start)
            path.reverse()
            return path

        # Explore neighbors
        for neighbor in graph.get(current_node, []):
            # Calculate the tentative g_score for the neighbor
            tentative_g_score = g_score[current_node] + 1  # Assuming cost of 1 for each step

            # If the tentative g_score is better than the current g_score
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current_node
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                # Add or update the neighbor in the open set
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return None  # No path found

# Example usage (assuming 'graph', 'start', and 'goal' are defined)
# start_node = (row_A, col_A)  # Replace with actual coordinates of 'A'
# goal_node = (row_Y, col_Y)    # Replace with actual coordinates of 'Y'
# path = a_star_search(graph, start_node, goal_node)

# if path:
#     print("Path found:")
#     print(path)
# else:
#     print("No path found.")

"""## Visualize the solution path

### Subtask:
Overlay the found path on the maze image to visualize the solution.

**Reasoning**:
Define the start and goal node coordinates based on visual inspection of the binary maze image, call the A* search function, and if a path is found, overlay it on a copy of the original image and display the result.
"""

import cv2
import numpy as np

# Step 1: Define the start and goal node coordinates
# Based on visual inspection of the inverted_binary_maze
# Assuming 'A' is near the top left and 'Y' is near the bottom right
# You might need to adjust these coordinates based on your specific image and where A and Y are located.
# Let's use example coordinates. You should replace these with actual observed coordinates.
start_node = (440, 426) # Example coordinates for 'A'
goal_node = (470, 497)  # Example coordinates for 'Y'

print(f"Start node: {start_node}")
print(f"Goal node: {goal_node}")


# Step 2: Call the a_star_search function
solution_path = a_star_search(graph, start_node, goal_node)

# Step 3: Check if a solution path was found
if solution_path is None:
    print("No path found from start to goal.")
else:
    print(f"Path found with {len(solution_path)} steps.")
    # Step 4: Create a copy of the original maze_image
    maze_with_path = maze_image.copy()

    # Step 5: Iterate through the coordinates in the solution path and draw markers
    # We skip the first node as it's the start
    for (r, c) in solution_path[1:]:
        # Draw a green circle at each path coordinate
        cv2.circle(maze_with_path, (c, r), 3, (0, 255, 0), -1) # (image, center, radius, color, thickness)

    # Step 6: Display the image with the highlighted path
    cv2_imshow(maze_with_path)

"""## Visualize the solution path

### Subtask:
Retry visualizing the solution path with corrected start and goal nodes.

**Reasoning**:
Define the correct start and goal node coordinates based on the visual appearance of 'A' and 'Y' in the `inverted_binary_maze` image, then call the `a_star_search` function and visualize the path if found.
"""

# Step 1: Define the corrected start and goal node coordinates
# Based on visual inspection of the inverted_binary_maze
# Let's re-examine the image to find better coordinates for 'A' and 'Y'.
# Looking at the image, 'A' seems to be around row 36, column 63.
# 'Y' seems to be around row 470, column 497.
start_node = (36, 63) # Corrected example coordinates for 'A'
goal_node = (470, 497)  # Corrected example coordinates for 'Y'

print(f"Corrected Start node: {start_node}")
print(f"Corrected Goal node: {goal_node}")

# Step 2: Call the a_star_search function with corrected nodes
solution_path = a_star_search(graph, start_node, goal_node)

# Step 3: Check if a solution path was found
if solution_path is None:
    print("No path found from corrected start to goal.")
else:
    print(f"Path found with {len(solution_path)} steps.")
    # Step 4: Create a copy of the original maze_image
    maze_with_path = maze_image.copy()

    # Step 5: Iterate through the coordinates in the solution path and draw markers
    # We skip the first node as it's the start
    for (r, c) in solution_path[1:]:
        # Draw a small green circle at each path coordinate
        cv2.circle(maze_with_path, (c, r), 3, (0, 255, 0), -1) # (image, center, radius, color, thickness)

    # Step 6: Display the image with the highlighted path
    cv2_imshow(maze_with_path)

"""## Visualize the solution path

### Subtask:
Retry visualizing the solution path with further refined start and goal nodes.

**Reasoning**:
Re-examine the maze image for more precise start and goal coordinates, update the variables, run the A* search again, and if a path is found, visualize it on a copy of the maze image.
"""

# Step 1: Re-examine the inverted_binary_maze image and define more precise start and goal node coordinates
# Looking very closely at the image, let's refine the coordinates.
# The start 'A' appears to be precisely at row 36, column 63.
# The goal 'Y' appears to be precisely at row 470, column 497.
# These were the same coordinates used in the previous attempt, indicating the issue might not be
# in the general area, but potentially in the exact pixel being a traversable path or an issue with the graph generation.
# Let's confirm if these exact pixels are indeed traversable in our graph.
# We can check if these nodes exist as keys in the graph dictionary.
if (36, 63) in graph and (470, 497) in graph:
    print("Refined start and goal nodes are traversable.")
    start_node = (36, 63)
    goal_node = (470, 497)
    print(f"Further refined Start node: {start_node}")
    print(f"Further refined Goal node: {goal_node}")

    # Step 2: Call the a_star_search function with further refined nodes
    solution_path = a_star_search(graph, start_node, goal_node)

    # Step 3: Check if a solution path was found
    if solution_path is None:
        print("No path found from further refined start to goal.")
    else:
        print(f"Path found with {len(solution_path)} steps.")
        # Step 4: Create a copy of the original maze_image
        maze_with_path = maze_image.copy()

        # Step 5: Iterate through the coordinates in the solution path and draw markers
        # We skip the first node as it's the start
        for (r, c) in solution_path[1:]:
            # Draw a small green circle at each path coordinate
            cv2.circle(maze_with_path, (c, r), 3, (0, 255, 0), -1) # (image, center, radius, color, thickness)

        # Step 6: Display the image with the highlighted path
        cv2_imshow(maze_with_path)
else:
    print("Refined start or goal nodes are not traversable in the graph. Please re-check coordinates or graph generation.")

"""**Reasoning**:
Since the refined start or goal nodes are reported as not traversable, the next step is to examine the `inverted_binary_maze` at those exact coordinates to confirm if they are indeed part of the traversable path (value 255) and to debug the graph generation if necessary.


"""

# Check the pixel values of the intended start and goal nodes in the inverted_binary_maze
start_r, start_c = 36, 63
goal_r, goal_c = 470, 497

if 0 <= start_r < height and 0 <= start_c < width:
    print(f"Pixel value at start node ({start_r}, {start_c}): {inverted_binary_maze[start_r, start_c]}")
else:
    print(f"Start node coordinates ({start_r}, {start_c}) are out of bounds.")

if 0 <= goal_r < height and 0 <= goal_c < width:
    print(f"Pixel value at goal node ({goal_r}, {goal_c}): {inverted_binary_maze[goal_r, goal_c]}")
else:
    print(f"Goal node coordinates ({goal_r}, {goal_c}) are out of bounds.")

# If the pixel values are not 255, it means these are not considered traversable by the current thresholding.
# If they are 255, there might be an issue in how the graph dictionary was populated.

"""**Reasoning**:
The previous check revealed that the goal node pixel value is 0, meaning it's being treated as a wall after thresholding and inversion. This is why it's not in the graph. The subtask is to retry visualizing the path with *further refined* start and goal nodes. Since the current goal node is a wall, we need to find a traversable pixel near the visible 'Y' character in the maze image to serve as a valid goal node for the A* search.


"""

# The goal node (470, 497) is a wall (pixel value 0).
# We need to find a traversable pixel (value 255) near the 'Y' in the maze.
# Let's visually inspect the image around the area of 'Y' (roughly 470, 497)
# to find a white pixel that is part of the path.
# We can check nearby pixels. Let's try shifting slightly to the left or up.

potential_goal_nodes = [
    (470, 496), # Slightly left
    (470, 495), # Further left
    (469, 497), # Slightly up
    (469, 496), # Slightly up and left
    (469, 495)  # Slightly up and further left
]

found_traversable_goal = False
for r, c in potential_goal_nodes:
    if 0 <= r < height and 0 <= c < width and inverted_binary_maze[r, c] == 255:
        refined_goal_node = (r, c)
        found_traversable_goal = True
        print(f"Found a traversable pixel near the goal at: {refined_goal_node}")
        break

if not found_traversable_goal:
    print("Could not find a nearby traversable pixel for the goal node. Please re-examine the image.")
    # If a traversable goal is not found, we cannot proceed with A* and visualization for this subtask.
    # In a real scenario, we might need to adjust the threshold or image processing.
else:
    # Update the goal node to the refined traversable one
    start_node = (36, 63) # Keep the start node as it was traversable
    goal_node = refined_goal_node

    print(f"Final Start node for A* search: {start_node}")
    print(f"Final Goal node for A* search: {goal_node}")

    # Step 3: Call the a_star_search function with the updated goal node
    solution_path = a_star_search(graph, start_node, goal_node)

    # Step 4: Check if a solution path was found
    if solution_path is None:
        print("No path found from refined start to refined goal.")
        # The subtask fails if a path is not found even with a traversable goal node.
    else:
        print(f"Path found with {len(solution_path)} steps.")
        # Step 5: Create a copy of the original maze_image
        maze_with_path = maze_image.copy()

        # Step 6: Iterate through the coordinates in the solution path and draw markers
        # We skip the first node as it's the start
        for (r, c) in solution_path[1:]:
            # Draw a small green circle at each path coordinate
            cv2.circle(maze_with_path, (c, r), 3, (0, 255, 0), -1) # (image, center, radius, color, thickness)

        # Step 7: Display the image with the highlighted path
        cv2_imshow(maze_with_path)

"""**Reasoning**:
The previous attempt to find a nearby traversable pixel for the goal node failed. This indicates that the area around the assumed location of 'Y' might not contain any traversable pixels based on the current thresholding. To fulfill the subtask of retrying visualization with refined nodes, we need to manually inspect the `inverted_binary_maze` image again to find a valid traversable pixel (value 255) that is clearly part of the path near the 'Y' character. Once a suitable pixel is identified, we will use those coordinates as the refined goal node and attempt the A* search and visualization again.


"""

# Manually re-examine the inverted_binary_maze image around the perceived location of 'Y'.
# Let's try a different set of coordinates based on visual inspection.
# Looking at the image, the path seems to extend slightly below the initial guess for 'Y'.
# Let's try coordinates (470, 495) again, but also consider other nearby points that appear white.
# Let's try (470, 495) as the refined goal node. We already checked its pixel value in the previous step and it was 0.
# Let's try (469, 495) - checked, also 0.
# Let's try (468, 495) - checked, also 0.
# Let's try (470, 494) - checking visually, this also seems to be a wall.
# Let's try moving slightly up and left from the original guess.
# Let's try (465, 490) - visually inspecting... this appears to be a white pixel within the path.
# Let's check its value in the inverted_binary_maze.

potential_refined_goal_node = (465, 490)

if 0 <= potential_refined_goal_node[0] < height and 0 <= potential_refined_goal_node[1] < width:
    pixel_value = inverted_binary_maze[potential_refined_goal_node[0], potential_refined_goal_node[1]]
    print(f"Pixel value at potential refined goal node {potential_refined_goal_node}: {pixel_value}")

    if pixel_value == 255:
        refined_goal_node = potential_refined_goal_node
        start_node = (36, 63) # Keep the traversable start node

        print(f"Using refined Start node for A* search: {start_node}")
        print(f"Using refined Goal node for A* search: {refined_goal_node}")

        # Step 2: Call the a_star_search function with the refined goal node
        solution_path = a_star_search(graph, start_node, refined_goal_node)

        # Step 3: Check if a solution path was found
        if solution_path is None:
            print("No path found from refined start to refined goal.")
            # The subtask fails if a path is not found.
        else:
            print(f"Path found with {len(solution_path)} steps.")
            # Step 4: Create a copy of the original maze_image
            maze_with_path = maze_image.copy()

            # Step 5: Iterate through the coordinates in the solution path and draw markers
            # We skip the first node as it's the start
            for (r, c) in solution_path[1:]:
                # Draw a small green circle at each path coordinate
                cv2.circle(maze_with_path, (c, r), 3, (0, 255, 0), -1) # (image, center, radius, color, thickness)

            # Step 6: Display the image with the highlighted path
            cv2_imshow(maze_with_path)
    else:
        print("The potential refined goal node is not traversable. Please re-examine the image.")

else:
    print(f"Potential refined goal node coordinates {potential_refined_goal_node} are out of bounds.")

"""## Summary:

### Data Analysis Key Findings

*   The initial attempt to find a path using visually estimated start node (440, 426) and goal node (470, 497) failed, as the A\* search returned no path.
*   Correcting the start node to (36, 63) and keeping the goal node at (470, 497) also resulted in no path found.
*   Further investigation revealed that the intended goal node (470, 497) had a pixel value of 0 in the `inverted_binary_maze`, indicating it was classified as a wall by the image processing steps. The start node (36, 63) was traversable (pixel value 255).
*   Attempts to find a nearby traversable pixel for the goal node by checking adjacent coordinates and manually inspecting the image around the location of 'Y' were unsuccessful. The tested potential goal nodes also had pixel values of 0 or were out of bounds.

### Insights or Next Steps

*   The current thresholding or image processing method may not be accurately capturing the traversable path near the 'Y' in the maze, or 'Y' itself is positioned on a wall pixel in the original image. Revisit the image processing steps, potentially adjusting the threshold value or using different techniques to ensure the path and the 'Y' location are correctly identified as traversable.
*   If 'Y' is indeed on a wall pixel in the original image, the task as stated (finding a path *to* 'Y') is impossible with this maze representation. A potential next step could be to redefine the goal as the closest traversable pixel to the perceived location of 'Y'.

"""